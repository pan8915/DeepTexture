<!DOCTYPE html>
<html lang="en">
<head>
	<title>Deep Texture Explorer</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		background:#fff;
		padding:0;
		margin:0;
		font-weight: bold;
		overflow:hidden;
	}
	</style>
</head>
<body>
	<script
	src="https://code.jquery.com/jquery-3.2.1.js"
	integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE="
	crossorigin="anonymous"></script>
	<script src="three.js"></script>
	<script src="Projector.js"></script>
	<script src="CanvasRenderer.js"></script>
	<script src="stats.min.js"></script>
	<script src="tween.min.js"></script>
	<!-- <script src='threex.domevent.js'></script> -->

	<script>
	<h1> Deep Texture Explorer </h1>

	var container, stats;
	var camera, scene, renderer, spheres;

	spheres = [];

	var raycaster;
	var intersection = false;
	var mouse;
	var geometry, group;
	var mouseX = 0, mouseY = 0;
	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;

	document.addEventListener( 'mousemove', onDocumentMouseMove, false );

	$(window).on('load',function() {
		$.getJSON( "textures_1.json", function( data ) {

			group = new THREE.Group();
			scene = new THREE.Scene();



			for (var i = 0; i < 360; i++){
				var geometry = new THREE.SphereGeometry( 15, 50, 50);
				var texture = new THREE.TextureLoader().load( 'images/' + data.filename[i] );
				var material = new THREE.MeshBasicMaterial({map: texture} );
				var sphere = new THREE.Mesh( geometry, material );
				sphere.position.x = data.coord[i][0]*500;
				sphere.position.y = Math.random() * 800 - 400;
				sphere.position.z = data.coord[i][1]*500;

				sphere.rotation.x = Math.random() * 2 * Math.PI;
				sphere.rotation.y = Math.random() * 2 * Math.PI;
				sphere.rotation.z = Math.random() * 2 * Math.PI;
				sphere.matrixAutoUpdate = false;
				sphere.updateMatrix();

				group.add( sphere );
				spheres.push(sphere);

			}
			scene.add( group );
		});

	});

	init();
	animate();

	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.z = 400;

		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor( 0xf0f0f0 );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild(renderer.domElement);

		stats = new Stats();
		container.appendChild( stats.dom );

		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'touchstart', onDocumentTouchStart, false );

		window.addEventListener( 'resize', onWindowResize, false );

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function onDocumentTouchStart( event ) {

			event.preventDefault();

			event.clientX = event.touches[0].clientX;
			event.clientY = event.touches[0].clientY;
			onDocumentMouseDown( event );

		}

		function onDocumentMouseDown( event ) {
			mouseX = ( event.clientX - windowHalfX ) * 2;
			mouseY = ( event.clientY - windowHalfY ) * 2;

			event.preventDefault();

			mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

			raycaster.setFromCamera( mouse, camera );
			var intersections = raycaster.intersectObjects( spheres );

			// the '?' is a ternary operator.

			// ________ ? ____ : ____
			intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;

			if (intersection) {
				// if(onClick){
					// camera.position = 检测鼠标位置（x，y，z） z－100；
				// }
				console.log('im intersecting!');
				// camera.position.z=
				// var intersects = raycaster.intersectObjects( scene.children );
				// new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
				// 	x: Math.random() * 800 - 400,
				// 	y: Math.random() * 800 - 400,
				// 	z: Math.random() * 800 - 400 }, 2000 )
				// 	.easing( TWEEN.Easing.Elastic.Out).start();

					// new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
					// 	x: Math.random() * 2 * Math.PI,
					// 	y: Math.random() * 2 * Math.PI,
					// 	z: Math.random() * 2 * Math.PI }, 2000 )
					// 	.easing( TWEEN.Easing.Elastic.Out).start();



				// inserctions[0] will contain the object you're clicking on
			}

			/*
			raycaster.setFromCamera( mouse, camera );

			var intersects = raycaster.intersectObjects( scene.children );

			if ( intersects.length > 0 ) {
				new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
					x: Math.random() * 800 - 400,
					y: Math.random() * 800 - 400,
					z: Math.random() * 800 - 400 }, 2000 )
					.easing( TWEEN.Easing.Elastic.Out).start();

					new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
						x: Math.random() * 2 * Math.PI,
						y: Math.random() * 2 * Math.PI,
						z: Math.random() * 2 * Math.PI }, 2000 )
						.easing( TWEEN.Easing.Elastic.Out).start();

					}
					*/
				}
			}

			function onDocumentMouseMove(event) {
				mouseX = ( event.clientX - windowHalfX ) * 2;
				mouseY = ( event.clientY - windowHalfY ) * 2;
			}

			//

			function animate() {


				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			var radius = 600;
			var theta = 0;

			function render() {
				TWEEN.update();
				theta += 0.1;

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

				// raycaster.setFromCamera( mouse, camera );
				// var intersections = raycaster.intersectObjects( spheres );
				//
				// // the '?' is a ternary operator.
				//
				// // ________ ? ____ : ____
				// intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null;
				//
				// if (intersection) {
				// 	console.log('im intersecting!');
				// 	console.log(intersection);
				// }

				var currentSeconds = Date.now();
				scene.rotation.x = Math.sin( currentSeconds * 0.00001) * 0.9;
				scene.rotation.y = Math.sin( currentSeconds * 0.00001) * 0.9;
				scene.rotation.z = Math.sin( currentSeconds * 0.00001 ) * 0.9;
				renderer.render( scene, camera );
			}


			</script>

		</body>
		</html>
