<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - interactive - cubes tween</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#fff;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}
		</style>
	</head>
	<body>
		<script
  	src="https://code.jquery.com/jquery-3.2.1.js"
  	integrity="sha256-DZAnKJ/6XZ9si04Hgrsxu/8s717jcIzLy3oi35EouyE="
  	crossorigin="anonymous"></script>
		<script src="three.js"></script>
		<script src="Projector.js"></script>
		<script src="CanvasRenderer.js"></script>
		<script src="stats.min.js"></script>
		<script src="tween.min.js"></script>

		<script>

			var container, stats;
			var camera, scene, renderer;

			var raycaster;
			var mouse;
			var geometry, group;
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var targetList = [];
			var TextureStorage = [];

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 700;


				scene = new THREE.Scene();
				//var texture = new THREE.TextureLoader().load( 'textures/bule.jpg' );

				//var geometry = new THREE.BoxGeometry( 20, 20, 20 );
				// var material = new THREE.MeshNormalMaterial( { overdraw: 0.5 } );

       $(window).on('load',function() {
				 $.getJSON( "textures_1.json", function( j ) {
		 	    data = j;
				  group = new THREE.Group();
		 			for (var i = 0; i < 360; i++){


		      //TextureStorage.push(Name);
					TextureStorage.push(sphere);

					var geometry = new THREE.SphereGeometry( 5, 30, 30);
					var texture = new THREE.TextureLoader().load( 'images/' + data.filename[i] );
					var material = new THREE.MeshBasicMaterial( { map: texture } );
					var sphere = new THREE.Mesh( geometry, material );
					sphere.position.x = data.coord[i][0]*500;
					sphere.position.y = 0;
					sphere.position.z = data.coord[i][1]*500;

					sphere.rotation.x = Math.random() * 2 * Math.PI;
					sphere.rotation.y = Math.random() * 2 * Math.PI;
					sphere.rotation.z = Math.random() * 2 * Math.PI;
					sphere.matrixAutoUpdate = false;
		      sphere.updateMatrix();

     			group.add( sphere );


					targetList.push(sphere);
		 		}
				scene.add( group );
				});

				});

				// for ( var i = 0; i < 100; i ++ ) {
				//
				// 	// var object = new THREE.Mesh( geometry, material);
				// 	// object.position.x =Math.random() * 800 - 400;//Math.random() * 800 - 600;
				// 	// object.position.y = Math.random() * 800 - 400;//Math.random() * 800 - 600;
				// 	// object.position.z = Math.random() * 800 - 400;//Math.random() * 800 - 600;
				// 	// object.scale.x = Math.random() + 0.5;
				// 	// object.scale.y = Math.random()  + 0.5;
				// 	// object.scale.z = Math.random() + 0.5;
				//
				//
				//
				// }

				//

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				renderer = new THREE.CanvasRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild(renderer.domElement);

				stats = new Stats();
				container.appendChild( stats.dom );

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );



			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentTouchStart( event ) {

				event.preventDefault();

				event.clientX = event.touches[0].clientX;
				event.clientY = event.touches[0].clientY;
				onDocumentMouseDown( event );

			}

			function onDocumentMouseDown( event ) {
				mouseX = ( event.clientX - windowHalfX ) * 10;
				mouseY = ( event.clientY - windowHalfY ) * 10;

				event.preventDefault();

				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
						x: Math.random() * 800 - 400,
						y: Math.random() * 800 - 400,
						z: Math.random() * 800 - 400 }, 2000 )
					.easing( TWEEN.Easing.Elastic.Out).start();

					new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
						x: Math.random() * 2 * Math.PI,
						y: Math.random() * 2 * Math.PI,
						z: Math.random() * 2 * Math.PI }, 2000 )
					.easing( TWEEN.Easing.Elastic.Out).start();

				}
			}
		}

			function onDocumentMouseMove(event) {
				mouseX = ( event.clientX - windowHalfX ) * 4;
				mouseY = ( event.clientY - windowHalfY ) * 4;
			  }

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			var radius = 600;
			var theta = 0;

			function render() {
				TWEEN.update();
				theta += 0.1;

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

				var currentSeconds = Date.now();
				scene.rotation.x = Math.sin( currentSeconds * 0.00001) * 0.9;
				scene.rotation.y = Math.sin( currentSeconds * 0.00001) * 0.9;
				scene.rotation.z = Math.sin( currentSeconds * 0.00001 ) * 0.9;
				renderer.render( scene, camera );
			}


		</script>

	</body>
</html>
